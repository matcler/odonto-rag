from __future__ import annotations

import argparse
import json
import math
import os
import re
from typing import Any, Dict, List, Optional, Tuple, Union

from pptx import Presentation
from pptx.enum.text import PP_ALIGN
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor


# ============================================================
# CONFIG (chairside fixed structure)
# ============================================================

LABEL_ORDER = ["DO", "AVOID", "CHECK", "RESCUE", "TIP"]

LABEL_COLORS = {
    "DO": RGBColor(0, 128, 0),
    "AVOID": RGBColor(192, 0, 0),
    "CHECK": RGBColor(0, 102, 204),
    "RESCUE": RGBColor(128, 0, 128),
    "TIP": RGBColor(102, 102, 102),
}

FONT_NAME = "Calibri"
TITLE_FONT_SIZE = 36
BULLET_FONT_SIZES = [22, 20, 18, 16]
PARA_SPACE_AFTER_PT = 8

# Geometry (16:9 friendly). Template created by this script uses these too.
TITLE_LEFT = Inches(0.7)
TITLE_TOP = Inches(0.35)
TITLE_WIDTH = Inches(12.0)
TITLE_HEIGHT = Inches(0.9)

BODY_LEFT = Inches(0.85)
BODY_TOP = Inches(1.35)
BODY_WIDTH = Inches(12.0)
BODY_HEIGHT = Inches(5.4)

TRUNCATE_CHAR_LIMIT = 220
TRUNCATE_SUFFIX = " …"

# slide_writer bullet string format: "Do: ..."
BULLET_LINE_RE = re.compile(r"^\s*([A-Za-z']+)\s*:\s*(.+?)\s*$")

# Optional preview parsing support
_PREVIEW_SLIDE_RE = re.compile(r"^\s*Slide\s+(\d+)\s*:\s*(.+?)\s*$", re.IGNORECASE)
_PREVIEW_BULLET_RE = re.compile(r"^\s*-\s*([A-Za-z]+)\s*:\s*(.+?)\s*$")


# ============================================================
# Errors
# ============================================================

class SlideSpecError(Exception):
    pass


# ============================================================
# JSON helpers
# ============================================================

def _load_json(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def _save_json(path: str, obj: Any) -> None:
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)


# ============================================================
# Label normalization
# ============================================================

def _label_norm(label: str) -> str:
    l = (label or "").strip().upper()
    if l in ("DO",): return "DO"
    if l in ("AVOID", "DONT", "DON'T"): return "AVOID"
    if l in ("CHECK",): return "CHECK"
    if l in ("RESCUE", "FIX"): return "RESCUE"
    if l in ("TIP", "PEARL"): return "TIP"
    return l


# ============================================================
# INPUT ADAPTERS
# ============================================================

def from_slide_writer_deck(deck: dict) -> dict:
    """
    Adapts slide_writer output:
      {"topic","audience","slides":[{"title","bullets":[str,...]}]}
    into internal spec:
      {"deck_title","language","slides":[{"title","bullets":[{"label","text"}...], "notes":""}]}
    """
    slides_in = deck.get("slides", [])
    if not isinstance(slides_in, list) or not slides_in:
        raise SlideSpecError("slide_writer deck has no slides.")

    slides_out = []
    for s in slides_in:
        if not isinstance(s, dict):
            continue
        title = str(s.get("title", "")).strip()
        if not title:
            continue

        bullets_in = s.get("bullets", [])
        parsed: List[Dict[str, str]] = []
        if isinstance(bullets_in, list):
            for line in bullets_in:
                m = BULLET_LINE_RE.match(str(line))
                if not m:
                    continue
                label = _label_norm(m.group(1))
                text = m.group(2).strip()
                parsed.append({"label": label, "text": text})

        slides_out.append({"title": title, "bullets": parsed, "notes": str(s.get("notes", "") or "").strip()})

    return {"deck_title": str(deck.get("topic", "")).strip(), "language": "", "slides": slides_out}

def parse_slide_writer_preview(text: str) -> dict:
    """
    Parses preview text format:
      Slide 1 : Title
       - Do: ...
    """
    slides = []
    cur = None
    for line in text.splitlines():
        m = _PREVIEW_SLIDE_RE.match(line)
        if m:
            if cur:
                slides.append(cur)
            cur = {"title": m.group(2).strip(), "bullets": [], "notes": ""}
            continue
        if cur:
            bm = _PREVIEW_BULLET_RE.match(line)
            if bm:
                cur["bullets"].append({"label": _label_norm(bm.group(1)), "text": bm.group(2).strip()})
    if cur:
        slides.append(cur)
    if not slides:
        raise SlideSpecError("Could not parse preview text: no slides found.")
    return {"deck_title": "", "language": "", "slides": slides}


# ============================================================
# NORMALIZATION (5 fixed rows)
# ============================================================

def normalize_slidespec(spec: dict) -> dict:
    """
    Ensures EXACTLY 5 rows in LABEL_ORDER.
    Duplicates: concatenate deterministically with " • ".
    Missing tags: empty string.
    """
    if not isinstance(spec, dict):
        raise SlideSpecError("slidespec must be a dict.")
    slides = spec.get("slides")
    if not isinstance(slides, list) or not slides:
        raise SlideSpecError("slidespec['slides'] must be a non-empty list.")

    out = {"deck_title": spec.get("deck_title", ""), "language": spec.get("language", ""), "slides": []}

    for i, s in enumerate(slides):
        if not isinstance(s, dict):
            raise SlideSpecError(f"slide[{i}] must be an object.")
        title = str(s.get("title", "")).strip()
        if not title:
            raise SlideSpecError(f"slide[{i}].title is required.")

        bullets_in = s.get("bullets", [])
        if not isinstance(bullets_in, list):
            raise SlideSpecError(f"slide[{i}].bullets must be a list.")

        mapped: Dict[str, str] = {}
        for b in bullets_in:
            if not isinstance(b, dict):
                continue
            label = _label_norm(str(b.get("label", "")))
            text = str(b.get("text", "")).strip()
            if not label:
                continue
            if label in mapped and text:
                mapped[label] = (mapped[label] + " • " + text).strip(" •")
            else:
                mapped[label] = text

        bullets_out = [{"label": lab, "text": mapped.get(lab, "")} for lab in LABEL_ORDER]
        notes = str(s.get("notes", "") or "").strip()
        out["slides"].append({"title": title, "bullets": bullets_out, "notes": notes})

    return out


# ============================================================
# OVERFLOW ESTIMATION (deterministic)
# ============================================================

def _estimate_lines(text: str, font_pt: int, width_in: float) -> int:
    if not text:
        return 1
    k = 0.55
    width_pt = width_in * 72
    chars_per_line = max(12, int((width_pt / font_pt) * k))
    return max(1, math.ceil(len(text) / chars_per_line))

def _estimate_total_height_pt(lines: int, font_pt: int, space_after_pt: int) -> int:
    line_height = int(1.15 * font_pt)
    return lines * line_height + space_after_pt

def _fits_in_body(bullets: List[Dict[str, str]], font_pt: int, body_width_in: float, body_height_in: float) -> bool:
    available_pt = int(body_height_in * 72)
    total_pt = 0
    for b in bullets:
        composed = f"{b['label']}: {b['text']}".strip()
        lines = _estimate_lines(composed, font_pt, body_width_in)
        total_pt += _estimate_total_height_pt(lines, font_pt, PARA_SPACE_AFTER_PT)
    return total_pt <= available_pt

def _truncate_if_needed(text: str, limit: int = TRUNCATE_CHAR_LIMIT) -> Tuple[str, bool]:
    text = (text or "").strip()
    if len(text) <= limit:
        return text, False
    return text[: max(0, limit - len(TRUNCATE_SUFFIX))].rstrip() + TRUNCATE_SUFFIX, True


# ============================================================
# PPTX LAYOUT HELPERS
# ============================================================

def _find_title_only_layout(prs: Presentation) -> int:
    """
    Finds a layout with title placeholder but no body placeholder.
    Works across many templates.
    """
    for i, layout in enumerate(prs.slide_layouts):
        has_title = False
        has_body = False
        for shp in layout.placeholders:
            t = shp.placeholder_format.type
            if t == 1:
                has_title = True
            if t == 2:
                has_body = True
        if has_title and not has_body:
            return i
    return 5 if len(prs.slide_layouts) > 5 else 0

def _set_title(slide, title: str):
    if slide.shapes.title is not None:
        title_shape = slide.shapes.title
        title_shape.text = title
        p = title_shape.text_frame.paragraphs[0]
        p.font.size = Pt(TITLE_FONT_SIZE)
        p.font.name = FONT_NAME
        return

    tb = slide.shapes.add_textbox(TITLE_LEFT, TITLE_TOP, TITLE_WIDTH, TITLE_HEIGHT)
    tf = tb.text_frame
    tf.clear()
    p = tf.paragraphs[0]
    run = p.add_run()
    run.text = title
    run.font.size = Pt(TITLE_FONT_SIZE)
    run.font.name = FONT_NAME
    run.font.bold = True
    p.alignment = PP_ALIGN.LEFT

def _render_bullets(slide, bullets: List[Dict[str, str]], chosen_font_pt: int, truncated_map: Dict[str, str]):
    tx = slide.shapes.add_textbox(BODY_LEFT, BODY_TOP, BODY_WIDTH, BODY_HEIGHT)
    tf = tx.text_frame
    tf.clear()
    tf.word_wrap = True

    for i, b in enumerate(bullets):
        label = b["label"]
        text = truncated_map.get(label, b.get("text", ""))

        p = tf.paragraphs[0] if i == 0 else tf.add_paragraph()
        p.space_after = Pt(PARA_SPACE_AFTER_PT)
        p.level = 0

        run_label = p.add_run()
        run_label.text = f"{label}: "
        run_label.font.bold = True
        run_label.font.size = Pt(chosen_font_pt)
        run_label.font.name = FONT_NAME
        run_label.font.color.rgb = LABEL_COLORS.get(label, RGBColor(0, 0, 0))

        run_text = p.add_run()
        run_text.text = text
        run_text.font.size = Pt(chosen_font_pt)
        run_text.font.name = FONT_NAME

def _append_notes(slide, base_notes: str, full_text_if_truncated: List[str]) -> None:
    notes_tf = slide.notes_slide.notes_text_frame
    parts = []
    if base_notes:
        parts.append(base_notes.strip())
    if full_text_if_truncated:
        parts.append("\n\n[TRUNCATED ON SLIDE — FULL TEXT]\n" + "\n".join(full_text_if_truncated))
    notes_tf.text = "\n".join(parts).strip()


# ============================================================
# TEMPLATE CREATOR (no manual fixes)
# ============================================================

def create_chairside_template(template_out: str) -> str:
    """
    Creates a simple 16:9 template PPTX with one example slide.
    You can duplicate and style it in PowerPoint later, but you DON'T have to.
    The builder can use this template as-is.
    """
    prs = Presentation()
    # Force 16:9 widescreen
    prs.slide_width = Inches(13.333)   # 13.333 in
    prs.slide_height = Inches(7.5)     # 7.5 in

    # Use a "Title Only" if present; otherwise blank
    layout_idx = _find_title_only_layout(prs)
    slide = prs.slides.add_slide(prs.slide_layouts[layout_idx])

    _set_title(slide, "CHAIRSIDE TEMPLATE — Example Title")

    # Draw example bullet block (so the template visually shows intended positions)
    example_bullets = [
        {"label": "DO", "text": "Example Do"},
        {"label": "AVOID", "text": "Example Avoid"},
        {"label": "CHECK", "text": "Example Check"},
        {"label": "RESCUE", "text": "Example Rescue"},
        {"label": "TIP", "text": "Example Tip"},
    ]
    _render_bullets(slide, example_bullets, chosen_font_pt=20, truncated_map={})

    os.makedirs(os.path.dirname(template_out) or ".", exist_ok=True)
    prs.save(template_out)
    return template_out


# ============================================================
# PUBLIC API
# ============================================================

def build_pptx(
    deck_or_spec: Union[str, Dict[str, Any]],
    out_path: str,
    template_path: Optional[str] = None,
    also_write_normalized_json: bool = True,
) -> str:
    """
    Accepts:
      - slide_writer deck dict (topic/audience/slides with bullets strings)
      - internal spec dict (deck_title/language/slides with bullets dicts)
      - JSON file path for either of the above
      - raw preview text containing "Slide 1 : ..." blocks (optional)
    """

    if isinstance(deck_or_spec, str):
        if os.path.exists(deck_or_spec):
            obj = _load_json(deck_or_spec)
        else:
            obj = parse_slide_writer_preview(deck_or_spec)
    else:
        obj = deck_or_spec

    # If it's slide_writer format, adapt it
    if isinstance(obj, dict) and "topic" in obj and "slides" in obj and "deck_title" not in obj:
        spec = from_slide_writer_deck(obj)
    else:
        spec = obj

    normalized = normalize_slidespec(spec)

    prs = Presentation(template_path) if template_path else Presentation()
    # If user template is not 16:9, we keep its own size by design.
    layout_idx = _find_title_only_layout(prs)

    for s in normalized["slides"]:
        slide = prs.slides.add_slide(prs.slide_layouts[layout_idx])
        _set_title(slide, s["title"])

        bullets = s["bullets"]

        chosen = None
        for font_pt in BULLET_FONT_SIZES:
            if _fits_in_body(bullets, font_pt, BODY_WIDTH.inches, BODY_HEIGHT.inches):
                chosen = font_pt
                break
        if chosen is None:
            chosen = BULLET_FONT_SIZES[-1]

        truncated_map: Dict[str, str] = {}
        full_text_notes: List[str] = []

        if not _fits_in_body(bullets, chosen, BODY_WIDTH.inches, BODY_HEIGHT.inches):
            for b in bullets:
                label = b["label"]
                original = b.get("text", "")
                t, did = _truncate_if_needed(original, TRUNCATE_CHAR_LIMIT)
                if did:
                    truncated_map[label] = t
                    full_text_notes.append(f"{label}: {original}")

        _render_bullets(slide, bullets, chosen, truncated_map)
        _append_notes(slide, s.get("notes", ""), full_text_notes)

    os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
    prs.save(out_path)

    if also_write_normalized_json:
        norm_path = os.path.splitext(out_path)[0] + ".slidespec.normalized.json"
        _save_json(norm_path, normalized)

    return out_path


# ============================================================
# CLI
# ============================================================

def main():
    ap = argparse.ArgumentParser(description="Chairside PPTX builder (deterministic, single-file).")
    sub = ap.add_subparsers(dest="cmd", required=True)

    ap_tpl = sub.add_parser("create-template", help="Create a baseline chairside template PPTX.")
    ap_tpl.add_argument("--out", dest="out", required=True, help="Output template path, e.g. templates/chairside_template.pptx")

    ap_build = sub.add_parser("build", help="Build final PPTX from slide_writer deck (JSON) or internal spec.")
    ap_build.add_argument("--in", dest="inp", required=True, help="Path to slide_writer deck JSON (or internal spec JSON).")
    ap_build.add_argument("--out", dest="out", required=True, help="Output PPTX path.")
    ap_build.add_argument("--template", dest="template", default=None, help="Optional PPTX template path.")

    args = ap.parse_args()

    if args.cmd == "create-template":
        create_chairside_template(args.out)
        print(f"OK template: {args.out}")
        return

    if args.cmd == "build":
        build_pptx(args.inp, args.out, template_path=args.template)
        print(f"OK pptx: {args.out}")
        return


if __name__ == "__main__":
    main()

